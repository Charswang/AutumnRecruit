## 事务

- 原子性  A   Atomicity
- **一致性**  C  Consistency
- 隔离性  I    Isolation
- 持久性  D   Durabilily

> 原子性、一致性、以及隔离性是手段，一致性是目的。

## 并发事务带来的一致性问题

- 脏读

  > 当一个线程A事务修改数据K的值【原本K=1，A修改为2】，在该事务A修改的数据还没有提交到数据库中的时候，另一个事务B读取到了A修改之后K的值，然后使用。因为修改后数据是还没有提交，**如果此刻事务A回滚了/撤销了这次修改**，那么K值又恢复为了1，但是此时B读到的数据为2，因此认为事务B读取的K值是”脏数据“，**导致B用读取到的K值进行操作出现问题。**

- 丢失修改

  > 两个事务A和B，每个事务都包含修改同一个数据，并在进行查询的操作；A对数据K进行修改，B也对数据K进行修改，A首先修改完成，B后修改完成，A在B修改之后读取数据发现自己修改的数据没有了。

- 不可重复读

  > 事务A中包括多次读取同一个数据的操作，第一次读取数据K的值为1，在A的两次对K值的读取操作中间，事务B将K值进行修改为2，导致事务A在第二次读取到的数据变成了2，这就**导致在同一个事务A中两次读取相同数据获取到的值是不同的**

- 幻读

  > 幻读与不可重复读类似。不过幻读是范围数据，并且事务A在第二次读取到的数据与第一次读取到的数据不同的地方在于：**第二次读取到的数据比第一次读到的数据要多，【仍包含第一次读的数据，事务B做的操作是在A读取的范围数据中又插入了数据】**
  >
  > **<font color="orange">使用快照读的话，不会发生幻读的情况，使用当前读就会发生幻读的情况了</font>**

  - 解决幻读的方式：
  
    添加**临键锁**，避免新数据的插入。

## 隔离【https://javaguide.cn/database/mysql/transaction-isolation-level.html】

提供四个隔离级别，【这四个隔离级别没能解决**“丢失修改问题”**】分别是

1、什么问题都不解决；  【读取未提交】

2、可解决脏读问题；  【读取已提交】**RC级别**

3、可解决脏读和不可重复读问题；  【可重复读】  **RR级别**

4、可解决脏读和不可重复读和幻读的问题的四个级别  【串行化】

**<font color="orange">使用分布式事务时，InnoDB 存储引擎的事务隔离级别必须设置为 SERIALIZABLE</font>**【布式事务指的是允许多个独立的事务资源（transactional resources）参与到一个全局的事务中；全局事务要求在其中的所有参与的事务要么都提交，要么都回滚，这对于事务原有的 ACID 要求又有了提高】



### 隔离的实现

> **基于锁和MVCC机制共同实现**

除了1、2、3使用MVCC外，隔离级别4使用锁来实现【因为要解决幻读，就要加间隙锁】



#### - RC,RR级别下的InnoDB快照读有什么不同？【https://www.pdai.tech/md/db/sql-mysql/sql-mysql-mvcc.html】

在RC级别下，快照读的快照是每个快照读都会获取到最新的快照视图，因此可以解决脏读问题，在另一个事务提交修改后，能够及时看到提交修改后的值

在RR级别下，快照读的快照仅由第一次快照读获取的快照试图，之后再进行快照读，都会读取之前第一次获取到的快照，这样才解决了不可重复读的问题。

#### - 快照读【一致性非锁定读】和当前读【一致性锁定读】和MVCC【多版本并发控制--多版本就是多个快照视图】有些关系。

## 锁

- 表级锁【针对非索引字段加的锁；实现简单，资源消耗也比较少，加锁快，不会出现死锁；锁整个表，并发写的情况下性能很差】

- 行级锁【针对索引字段加的锁；锁粒度最小，并发度高；但加锁的开销也最大，加锁慢，会出现死锁】

  - 记录锁--Record Lock

    **属于单个行记录的锁**

  - 间隙锁--Gap Lock

    **<font color="orange">锁定一个范围：是当前数据库表中在过该范围不存在记录的一个范围【也已作为临键锁中结合间隙锁来避免新纪录插入的操作】</font>**，不包括记录本身

  - 临键锁--Next-key Lock

    等于Record Lock+Gap Lock，锁定一个范围，包含记录本身。

    要结合间隙锁使用的原因：**记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。**

锁兼容：允许多个事务获取同一个锁【解锁？】，可以对同个资源加锁。【如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）】【一个记录/资源可以同时加上的锁】

锁互斥：不允许多个事务获取同一个锁，不可以多同个资源加锁。【一个记录/资源只能在两个锁中选择一个添加到资源上。】

- 共享锁【表级锁和行级锁】

  S锁，读锁；

- 排他锁【表级锁和行级锁】

  X锁，写锁；

  |          |  S 锁  | X 锁 |
  | :------: | :----: | :--: |
  | **S 锁** | 不冲突 | 冲突 |
  | **X 锁** |  冲突  | 冲突 |

#### 意向锁：**<font color="red">用来表示一个事务想要在表中的*某个数据行上*加X锁或S锁。</font>**

> 背景：如果想要加一个表级锁，那么需要判断这个表是否有被加锁，在判断的时候，由于这个表里的数据有可能加了行级锁，那么我们就得一行一行的遍历，看有没有行记录加了行锁，这就导致效率极慢。因此可以考虑加个意向锁，
>
> 意向锁是表级锁；我们可以通过意向锁来判断是否可以对某个表使用表锁。

- 意向共享锁【表级锁，**<font color="lightblue">意向锁与行级的S锁和X锁不互斥，只和表级的S锁和X锁互斥</font>**--**互斥：比如A事务加了表级X锁，那么事务B就没办法获得意向共享锁和意向排他锁**】
- 意向排他锁【表级锁】

一个事务A对表1添加了表级X锁【因为表级X锁与IX锁互斥，所以这里不能加IX锁】。此时事务B想要对表1中的某一行添加X锁，那么先获取表1的IX锁，因为IX锁与表级X锁互斥所以添加失败。

一个事务A对表1中的行2加了行级X锁，同时会有IX也加上了。此时事务B想要对表1添加X锁，加表级X锁不用获取IX？，X锁与IX锁互斥所以添加失败。

一个事务A想对表1的行1添加X锁，首先获取IX锁，然后添加行级X锁。此时事务B相对表1的行2添加锁，首先获取IX锁【因为此时表上只有IX锁，IX锁与IX锁是兼容的，因此可以加】，然后添加行2的X锁，因为事务A添加的是行1的X锁，因此这里添加行2的X锁也是可以成功的。

S和X是表级锁的情况下的兼容性如下所示。【如果S和X锁是行级锁的话，就不是这样了】

![image-20220724165441830](C:\Users\10435\AppData\Roaming\Typora\typora-user-images\image-20220724165441830.png)

获取锁和加锁：啥意思呀，啥区别？--意思应该都是对某个资源添加锁

---

## <font color="orange">MVCC--多版本并发控制</font>【加强理解一下】

多版本控制就是对快照读/一致性非锁定读的实现。

### 快照读  /  一致性非锁定读

使用版本号/时间戳来定义版本。一般读取的是历史版本的数据。

> 一般情况下select语句都是快照读/一致性非锁定读。但是
>
> select ... lock in share mode  和  select ... for  update是使用锁定读。

#### - RC,RR级别下的InnoDB快照读有什么不同？【https://www.pdai.tech/md/db/sql-mysql/sql-mysql-mvcc.html】

在RC级别下，快照读的快照是每个快照读都会获取到最新的Read View，因此可以解决脏读问题，在另一个事务提交修改后，能够及时看到提交修改后的值。【**每次快照读，都会生成一个版本的Read View**】

在RR级别下，快照读的快照仅由第一次快照读获取的Read View，之后再进行快照读，都会读取之前第一次获取到的快照，这样才解决了不可重复读的问题。【**事务的第一次快照读，生成的Read View**】

### 当前读  /  一致性锁定读

> 读取到的是最新版本的数据。

锁定读会对读取到的记录加锁：

- `select ... lock in share mode`：**对记录加 `S` 锁**，其它事务也可以加`S`锁，如果加 `x` 锁则会被阻塞
- `select ... for update`、`insert`、`update`、`delete`：**对记录加 `X` 锁**，且其它事务不能加任何锁

使用当前读的时候，在RepeatRead隔离级别下，会利用临键锁来防止幻读的发生【因为使用当前读，每次读取的都是最新的数据，一个事务中的两次读取之间可能会发生幻读/可能会有数据插入】

### MVCC的实现--【不能解决写写冲突--丢失修改问题--一般需要MVCC结合悲观锁/乐观锁来解决】

MVCC是用来解决读写【脏读、不可重复读、幻读--还要结合临键锁】之间的并发冲突问题的一种**无锁并发控制**。让**读操作时不用阻塞写操作，写操作也不用阻塞读操作**。

>  **<font color="orange">每次修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照</font>**

### 实现--【 **<font color="orange">加强理解一下</font>**】

可见性：当前的这一行的最新记录是否对当前事务有可见性？
