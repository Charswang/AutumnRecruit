### <font color="orange">Native 方法</font>

> java代码中调用的非java语言实现的代码部分，这块非java语言的代码块就是**Native 方法**

---

### <font color="orange">底层malloc函数</font>

在java内存模型中会通过JNI调用一些C语言写的底层代码实现内存分配。

void *malloc(unsigned int size)作用就是在内存动态存储区分配一个长度为size的连续空间。返回值是分配区域的起始地址。

### <font color="orange">浅拷贝与深拷贝</font>

clone()方法的重写；【**clone本身是浅拷贝**】【**如果重写clone方法可以实现深拷贝**】

- 浅拷贝：拷贝对象与原始对象的引用类型指向同一个对象；
- 深拷贝：拷贝对象与原始对象的引用类型指向不同的对象；

### <font color="orange">序列化与反序列化</font>

#### 1、、是什么

**序列化**：就是将**对象转化成字节序列**的过程。

**反序列化**：就是讲**字节序列转化成对象**的过程。

对象序列化成的字节序列会包含对象的类型信息、对象的数据等，说白了就是包含了描述这个对象的所有信息，能根据这些信息“复刻”出一个和原来一模一样的对象。

#### 2、为什么

那么为什么要去进行序列化呢？有以下两个原因

1. 持久化：对象是存储在JVM中的堆区的，但是如果JVM停止运行了，对象也不存在了。**序列化可以将对象转化成字节序列，可以写进硬盘文件中实现持久化**。在新开启的JVM中可以读取字节序列进行反序列化成对象。
2. 网络传输：网络直接**传输数据，但是无法直接传输对象，可在传输前序列化**，传输完成后反序列化成对象。所以所有可在网络上传输的对象都必须是可序列化的。

**序列化与反序列化是耗时的且消耗资源的。**

---

### <font color="orange">代码中的初始化顺序</font>

- 父类【静态变量、静态语句块】
- 子类【静态变量、静态语句块】
- 父类【实例变量、普通语句块】
- 父类【构造函数】
- 子类【实例变量、普通语句块】
- 子类【构造函数】

---

###  <font color="orange">异常</font>

**异常种类**：

- Error【JVM不能处理的异常】
- Exception
  - 受检异常
  - 非受检异常

**<font color="lightblue">详细的去看git库/pdai.tech</font>**

---

### <font color="red">泛型里面不熟的知识</font>

- **泛型上下限的引入：**

```java
<?> 无限制通配符
<? extends E> extends 关键字声明了类型的上界，表示参数化的类型可能是所指定的类型，或者是此类型的**子类**
<? super E> super 关键字声明了类型的下界，表示参数化的类型可能是指定的类型，或者是此类型的**父类**

// 使用原则《Effictive Java》
// 为了获得最大限度的灵活性，要在表示 生产者或者消费者 的输入参数上使用通配符，使用的规则就是：生产者有上限、消费者有下限
1. 如果参数化类型表示一个 T 的生产者，使用 < ? extends T>;
2. 如果它表示一个 T 的消费者，就使用 < ? super T>；
3. 如果既是生产又是消费，那使用通配符就没什么意义了，因为你需要的是精确的参数类型。
```

```java
<E extends Comparable<? extends E>> // ???  看在那种sort的方法中，会用到这种方法。
```



---

### <font color="orange">反射里面不熟的知识</font>

> 不是在编译时期，而是在**运行态**中，发现和使用类的信息。反射就是把java类中的各个部分【成员变量、方法、包等】映射成一个个对象

#### Class类

- Class类也是类的一种，但是与class关键字是不同的
- 程序编译之后会产出一个Class对象，并产生一个class文件，创建的类的类型信息保存在class这个**字节码文件**中
- 每个通过class关键字标识的类，在内存中只有一个与之对应的class对象，不管有多少实例，都用的是同一个Class对象
- Class类只有私有构造函数，因此对应的Class对象只能有JVM创建和加载  == 【<font color="red">没懂，这里说的JVM创建和加载什么意思？</font>】
- Class类的对象作用是**运行时**提供某个对象的类型信息，**对于反射很重要**。

获取Class对象：

- 类名.class
- 对象.getClass()
- Class.getName(全限定类名)

#### Constructor类

> 代表的是Class对象所表示的类的**构造方法。**
>
> 里面是有一些方法的，具体的看pdai.tech吧。

### Field类

> 提供有关类或接口的单个字段的信息，以及动态访问权限。
>
> 总体上看来：**比如会输出一个字段在哪个包下面的哪个类上，访问权限是public还是其他。**
>
> eg: **public  java.lang.String/int  com.wh.Student,age**

### Method类

> 与Field类似，但是返回的是**某个方法的信息与访问权限**
>
> **eg: public  final  native  void  reflect.Shape.draw(int,java.lang.String)**
>
> native应该是代表非java语言的方法。

### <font color="orange">反射机制执行的流程</font>

> 有点深入，还没太了解

#### <font color="orange">类加载&双亲委派机制</font>

> 可在gir库中的**JVM**那里找到。

---



