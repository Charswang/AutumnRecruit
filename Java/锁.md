[参考](https://pdai.tech/md/java/thread/java-thread-x-lock-all.html)

### 总体Java锁的分类图

<img src="JavaImage/java-lock-1.png" alt="Java锁的总体分类" style="zoom: 50%;" />

- **<font color="orange">悲观锁</font>适合写操作多的场景**，先加锁可以保证写操作时数据正确。
- **<font color="orange">乐观锁</font>适合读操作多的场景**，不加锁的特点能够使其读操作的性能大幅提升。



- **<font color="orange">自旋锁</font>**：【有时候，可能请求锁的线程在获得锁之后，锁定同步资源的时间极短，那么cpu状态转换消耗的时间有可能比用户代码执行的时间还要长。】因此为了减少cpu切换和恢复现场导致的消耗，可以使用自旋锁，让当前请求锁的线程不放弃cpu，从而进行自旋。如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么**当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销**。这就是自旋锁。

- **<font color="orange">非自旋锁</font>**：就是正常的阻塞，请求锁，切换状态，然后获得共享资源的锁，执行语句

<img src="JavaImage/自旋锁.png" alt="自旋锁" style="zoom: 40%;" />

> 自旋锁本身是有缺点的，它不能代替阻塞。**自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。**所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。
>
> <font color="red">怎么进行自旋的？</font>

- <font color="orange">自适应自旋锁</font>：使用自旋锁可能会出现一种情况就是：如果线程锁在线程中的自旋刚结束，之前请求的锁就被释放了，**这样反而会有些得不偿失**。所以这里就需要更灵活的自旋，来提高并发性能。

  自适应自旋锁的自旋时间不像自旋锁那样是固定的，自适应自旋锁的自旋时间是根据上一次/前几次在同一个锁上自旋的时间以及锁的拥有者的状态决定的。

  > 如果在同一个锁对象上，自旋等待刚刚成功获取过锁，并且持有锁的线程正在运行中，那么JVM会认为该锁自旋获取到锁的可能性很大，会自动增加等待时间。比如增加到100此循环。相反，如果对于某个锁，自旋很少成功获取锁。那再以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，JVM对程序的锁的状态预测会越来越准确，JVM也会越来越聪明。



**CAS通常会和自旋连在一块说。但是目前有些迷**

CAS如果在一次对比中，发现当前内存值与预期的预期值不同，那么会启用自旋操作进行不断重试？重试是怎样重试的？一直重试直到成功是什么意思？



- <font color="orange">无锁</font>
- <font color="orange">偏向锁</font>
- <font color="orange">轻量级锁</font>
- <font color="orange">重量级锁</font>

> synchronized的四种状态。**从上到下**逐渐升级，锁是可以升级的，但是不可以降级。目的是提供获取和释放锁的效率。？





- <font color="orange">公平锁</font>

线程直接进入队列中排队

公平锁的优点是**等待锁的线程不会饿死**。缺点是**整体吞吐效率相对非公平锁要低**，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。

- <font color="orange">非公平锁</font>

非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。

非公平锁的优点是可以**减少唤起线程的开销，整体的吞吐效率高**，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程【【因为非公平锁可能会出现不用被阻塞，而直接获得锁，这样避免了1次cpu的切换】】。缺点是处于**等待队列中的线程可能会饿死，或者等很久才会获得锁**。





- <font color="orange">可重入锁/递归锁</font> --  ReentrantLock和synchronized都是可重入锁

> 可重入锁的一个优点是可一定程度避免死锁

可重入锁是指同一个线程一个对象的一个方法获得锁之后，执行这个方法的过程中，还要进入另一个该对象的加锁的方法，此时，可以自动获取该对象的锁，成功执行这个内层的方法。不会因为之前已经获取过还没释放而阻塞。

否则的话【非可重入锁】会造成死锁，比如开始调用的是a方法，a方法中会调用b方法，两个方法都加了synchronized，**此时的synchronized是对象锁**，如果想让当前的对象锁释放，那么就要执行b方法，但是执行b方法还需要获取该对象锁，因此就会造成死锁现象。

- <font color="orange">非可重入锁</font>

> 可能会出现死锁情况





- <font color="orange">共享锁</font>/S锁/读锁/-表锁？

**共享锁**是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。【因为在读的过程中修改数据，可能会造成读取的数据不一致的情况/查不到数据的情况】

- <font color="orange">排他锁</font>/独享锁/X锁/写锁/-行锁？

**独享锁也叫排他锁**，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK中的synchronized和JUC中Lock的实现类就是互斥锁。

加入了排他锁之后，其他线程应该是既不能读，也不能写了





- <font color="orange">对象锁</font> -- 每个实例都对应有自己的一把锁(this),不同实例之间互不影响
- <font color="orange">类锁</font> -- 锁对象是*.class以及synchronized修饰的是static方法的时候



**<font color="lightblue">happens-before原则==先行发生原则【star 的git库里的java基础中有写】</font>**

> Happens-before 是用来指定两个操作之间的执行顺序。提供跨线程的内存可见性。
>
> 在 Java 内存模型中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必然存在 happens-before 关系。



<font color="gree">**锁优化背景：**</font>大量的将进程从用户态与内核态来回切换，会带来很多不必要的消耗，会严重影响系统性能。

**自旋锁 / 自适应自旋锁 / 锁粗化 / 锁消除 / 轻量级锁 / 偏向锁；**

<font color="orange">锁粗化</font>：减少不必要的紧连在一起的unlock，lock操作，将多个连续的锁扩展成一个更大的锁。

<font color="orange">锁消除</font>：JAVA  API 中往往会对很多方法加了同步的，但实际情况中，我们清楚的知道哪些线程是独有的，如果判断某个数据不会逃逸，那么可以对其进行锁消除。

> **数据逃逸/逃逸分析**：一个线程用到的程序/数据会不会被其他线程访问到；实际环境中，我们会清楚的知道哪些线程是独有的，如果判断某个数据不会逃逸，那么可以对其进行锁消除。

> 比如如下操作：在操作String类型数据时，由于String是一个不可变类，对字符串的连接操作总是通过生成的新的String对象来进行的。因此Javac编译器会对String连接做自动优化。在JDK 1.5之前会使用**StringBuffer**对象的连续append()操作，在JDK 1.5及以后的版本中，会转化为**StringBuidler**对象的连续append()操作。
>
> StringBuilder是线程不安全的。所以这里就用到了锁消除，变成了StringBuilder。

<font color="orange">轻量级锁</font>：对不会出现同步块竞争的同步块使用，可以减少重量级锁对线程阻塞带来的线程开销。【轻量级锁并不是替代重量级锁】

**<font color="red">具体情况？？还没看懂</font>**

<font color="orange">偏向锁</font>：在大多实际环境下，**锁不仅不存在多线程竞争，而且总是由同一个线程多次获取**，那么在同一个线程反复获取所释放锁中，其中并还没有锁的竞争，那么这样看上去，多次的获取锁和释放锁带来了很多不必要的性能开销和上下文切换。

**<font color="red">具体情况？？还没看懂</font>**



